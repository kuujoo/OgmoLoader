using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.Runtime.Serialization;
using System.Xml.Serialization;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

// Based on:
//https://github.com/EnoughTea/MonoBMFont

namespace kuujoo.Pixel {
    [DataContract]
    public class FontTexture
    {
        [XmlAttribute("id")]
        public int Id { get; set; }

        [XmlAttribute("file")]
        public string File { get; set; }
    }

    [DataContract]
    public class FontKerningPair
    {
        [XmlAttribute("first")]
        public int First { get; set; }

        [XmlAttribute("second")]
        public int Second { get; set; }

        [XmlAttribute("amount")]
        public int Amount { get; set; }
    }

    [DataContract]
    public class FontInfo
    {
        private Rectangle _padding;
        private Point _spacing;

        [XmlAttribute("face")]
        public string Face { get; set; }

        [XmlAttribute("size")]
        public int Size { get; set; }

        [XmlAttribute("bold")]
        public int Bold { get; set; }

        [XmlAttribute("italic")]
        public int Italic { get; set; }

        [XmlAttribute("charset")]
        public string CharSet { get; set; }

        [XmlAttribute("unicode")]
        public int Unicode { get; set; }

        [XmlAttribute("stretchH")]
        public int StretchHeight { get; set; }

        [XmlAttribute("smooth")]
        public int Smooth { get; set; }

        [XmlAttribute("aa")]
        public int SuperSampling { get; set; }

        [XmlAttribute("padding")]
        public string Padding
        {
            get { return _padding.X + "," + _padding.Y + "," + _padding.Width + "," + _padding.Height; }
            set
            {
                var padding = value.Split(',');
                _padding = new Rectangle(Convert.ToInt32(padding[0]), Convert.ToInt32(padding[1]),
                    Convert.ToInt32(padding[2]), Convert.ToInt32(padding[3]));
            }
        }

        [XmlAttribute("spacing")]
        public string Spacing
        {
            get { return _spacing.X + "," + _spacing.Y; }
            set
            {
                var spacing = value.Split(',');
                _spacing = new Point(Convert.ToInt32(spacing[0]), Convert.ToInt32(spacing[1]));
            }
        }

        [XmlAttribute("outline")]
        public int OutLine { get; set; }
    }

    [DataContract]
    public class FontGlyph
    {
        [XmlAttribute("id")]
        public int Id { get; set; }

        [XmlAttribute("x")]
        public int X { get; set; }

        [XmlAttribute("y")]
        public int Y { get; set; }

        [XmlAttribute("width")]
        public int Width { get; set; }

        [XmlAttribute("height")]
        public int Height { get; set; }

        [XmlAttribute("xoffset")]
        public int XOffset { get; set; }

        [XmlAttribute("yoffset")]
        public int YOffset { get; set; }

        [XmlAttribute("xadvance")]
        public int XAdvance { get; set; }

        [XmlAttribute("page")]
        public int Page { get; set; }

        [XmlAttribute("chnl")]
        public int Channel { get; set; }
    }

    /// <summary> Represents BMFont data which can be used for font rendering. </summary>
    [DataContract, XmlRoot("font")]
    public class FontData
    {
        [XmlElement("info")]
        public FontInfo Info { get; set; }

        [XmlElement("common")]
        public FontCommon Common { get; set; }

        [XmlArray("pages"), XmlArrayItem("page")]
        public List<FontTexture> Textures { get; set; }

        [XmlArray("chars"), XmlArrayItem("char")]
        public List<FontGlyph> Chars { get; set; }

        [XmlArray("kernings"), XmlArrayItem("kerning")]
        public List<FontKerningPair> Kernings { get; set; }

        /// <summary> Generates the kerning map.</summary>
        public Dictionary<char, Dictionary<char, int>> GenerateKerningMap()
        {
            var kerningMap = new Dictionary<char, Dictionary<char, int>>();
            foreach (var kerning in Kernings)
            {
                Dictionary<char, int> existing;
                if (!kerningMap.TryGetValue((char)kerning.First, out existing))
                {
                    existing = new Dictionary<char, int>();
                    kerningMap.Add((char)kerning.First, existing);
                }

                existing.Add((char)kerning.Second, kerning.Amount);
            }

            return kerningMap;
        }

        /// <summary> Gets the texture name generated by BMFont, consisting of font file name with added "_N.png".
        /// </summary>
        /// <param name="fontName">Font file name.</param>
        /// <param name="texPageIndex">Texture page index (N in "fontname_N.png", usually 0.</param>
        /// <returns>Corresponding texture for the font</returns>
        public static string GetTextureNameForFont(string fontName, int texPageIndex = 0)
        {
            var textureFilename = Path.GetFileNameWithoutExtension(fontName) + "_" + texPageIndex + ".png";
            var texturePath = Path.GetDirectoryName(fontName);
            return (texturePath != null) ? Path.Combine(texturePath, textureFilename) : textureFilename;
        }

        /// <summary>Loads BMFont data from the specified XML text reader.</summary>
        /// <param name="reader">The XML text reader.</param>
        /// <returns>BMFont data.</returns>
        public static FontData Load(TextReader reader)
        {
            var deserializer = new XmlSerializer(typeof(FontData));
            return (FontData)deserializer.Deserialize(reader);
        }

        /// <summary>Loads BMFont data from the specified XML data stream.</summary>
        /// <param name="stream">The XML data stream.</param>
        /// <returns>BMFont data.</returns>
        public static FontData Load(Stream stream)
        {
            var deserializer = new XmlSerializer(typeof(FontData));
            return (FontData)deserializer.Deserialize(stream);
        }
    }

    [DataContract]
    public class FontCommon
    {
        [XmlAttribute("lineHeight")]
        public int LineHeight { get; set; }

        [XmlAttribute("base")]
        public int Base { get; set; }

        [XmlAttribute("scaleW")]
        public int TextureWidth { get; set; }

        [XmlAttribute("scaleH")]
        public int TextureHeight { get; set; }

        [XmlAttribute("pages")]
        public int TextureCount { get; set; }

        [XmlAttribute("packed")]
        public int Packed { get; set; }

        [XmlAttribute("alphaChnl")]
        public int AlphaChannel { get; set; }

        [XmlAttribute("redChnl")]
        public int RedChannel { get; set; }

        [XmlAttribute("greenChnl")]
        public int GreenChannel { get; set; }

        [XmlAttribute("blueChnl")]
        public int BlueChannel { get; set; }
    }

    /// <summary> Represents a sprite font based on BMFont tool: http://www.angelcode.com/products/bmfont/. </summary>
    /// <remarks> Supports only single texture fonts. </remarks>
    public sealed class BMFont {
        /// <summary> File extension used by BMFont tool. </summary>
        public const string Extension = ".fnt";

        private Dictionary<char, Dictionary<char, int>> _kerningMap;
        private int _lineSpacing;

        /// <summary> Initializes a new instance of the <see cref="BMFont" /> class. </summary>
        /// <param name="texture">Font texture.</param>
        /// <param name="fontDesc">BMFont description.</param>
        /// <param name="spacing">Text spacing.</param>
        /// <param name="defaultCharacter">CSharacter optionally used for resolving unknown characters.</param>
        /// <exception cref="ArgumentNullException"><paramref name="texture"/> is <see langword="null"/>
        /// -or- <paramref name="fontDesc"/> is <see langword="null"/></exception>
        public BMFont(Texture2D texture, FontData fontDesc, float spacing = 0,
            char? defaultCharacter = ' ') {
            if (texture == null) {
                throw new ArgumentNullException(nameof(texture));
            }

            if (fontDesc == null) {
                throw new ArgumentNullException(nameof(fontDesc));
            }

            Init(texture, fontDesc, spacing, defaultCharacter);
        }

        /// <summary> Gets the characters supported by the font and their font data. </summary>
        public ReadOnlyDictionary<char, FontGlyph> Characters { get; private set; }

        /// <summary> Gets the BMFont description. </summary>
        public FontData Data { get; private set; }

        /// <summary> Gets or sets the default character. </summary>
        public char? DefaultCharacter { get; set; }

        /// <summary>
        ///     Gets or sets the vertical distance (in pixels) between the base lines of two consecutive
        ///     lines of text. Line spacing includes the blank space between lines as well as the height of the characters.
        /// </summary>
        public int LineSpacing { get { return _lineSpacing; } set { _lineSpacing = Math.Abs(value); } }

        /// <summary>Gets or sets the spacing of the font characters. </summary>
        public float Spacing { get; set; }

        /// <summary> Gets the texture map for the font. </summary>
        public Texture2D Texture { get; private set; }

        /// <summary> Gets the kerning amount between two font characters. </summary>
        /// <param name="first">The first characters.</param>
        /// <param name="second">The second characters.</param>
        /// <returns>Kerning amount in pixels.</returns>
        public int GetKerning(char first, char second) {
            var kerning = 0;
            Dictionary<char, int> firstKerningPairs;
            if (_kerningMap.TryGetValue(first, out firstKerningPairs)) {
                firstKerningPairs.TryGetValue(second, out kerning);
            }

            return kerning;
        }

        /// <summary> Returns the width and height of a string. </summary>
        /// <param name="text">The text to measure.</param>
        /// <returns>The width and height, in pixels, of text, when it is rendered. </returns>
        /// <exception cref="ArgumentNullException"><paramref name="text"/> is <see langword="null"/></exception>
        public Vector2 MeasureString(string text) {
            if (text == null) {
                throw new ArgumentNullException(nameof(text));
            }
            if (text.Length == 0) {
                return Vector2.Zero;
            }

            return ProcessChars(text, null, null);
        }

        /// <exception cref="ArgumentNullException"><paramref name="text"/> is <see langword="null"/></exception>
        internal Vector2 ProcessChars(string text, EachChar eachChar, Action newLineBegins) {
            if (text == null) {
                throw new ArgumentNullException(nameof(text));
            }

            var currentX = 0;
            var currentY = 0;
            var maxLineWidth = 0;
            var maxCharHeight = LineSpacing;
            char? previous = null;

            foreach (var c in text) {
                if (c == '\r') {
                    continue;
                }
                if (c == '\n') {
                    currentX -= (int)Spacing;
                    maxLineWidth = Math.Max(maxLineWidth, currentX);
                    currentX = 0;
                    currentY += maxCharHeight;
                    maxCharHeight = LineSpacing;
                    newLineBegins?.Invoke();
                    continue;
                }

                var actual = c;

                FontGlyph charData;
                if(!Characters.TryGetValue(actual, out charData) )
                {
                    if (!DefaultCharacter.HasValue)
                    {
                        throw new ArgumentException("Text contains characters that cannot be resolved by this font.",
                            nameof(text));
                    }
                    charData = Characters[DefaultCharacter.Value];
                    actual = DefaultCharacter.Value;
                }

                var kerning = 0;
                if (previous.HasValue) {
                    kerning = GetKerning(previous.Value, c);
                }

                var position = new Vector2(currentX + charData.XOffset + kerning, currentY + charData.YOffset);
                eachChar?.Invoke(actual, position, charData, previous);

                previous = actual;
                currentX += charData.XAdvance + kerning + (int)Spacing;
                if (charData.Height > maxCharHeight) {
                    maxCharHeight = charData.Height;
                }
            }

            currentY += maxCharHeight;
            return new Vector2(Math.Max(maxLineWidth, currentX), currentY);
        }

        private void Init(Texture2D texture, FontData fontDesc, float spacing, char? defaultCharacter) {
            if (texture == null) {
                throw new ArgumentNullException(nameof(texture));
            }

            if (fontDesc == null) {
                throw new ArgumentNullException(nameof(fontDesc));
            }

            var characterMap = new Dictionary<char, FontGlyph>(fontDesc.Chars.Count);
            foreach (var fontCharacter in fontDesc.Chars) {
                var c = (char)fontCharacter.Id;
                characterMap.Add(c, fontCharacter);
            }

            _kerningMap = fontDesc.GenerateKerningMap();

            Characters = new ReadOnlyDictionary<char, FontGlyph>(characterMap);
            Data = fontDesc;
            DefaultCharacter = defaultCharacter;
            if (DefaultCharacter.HasValue && !characterMap.ContainsKey(DefaultCharacter.Value)) {
                throw new ArgumentException("Given default character does not exist in the font.",
                    nameof(defaultCharacter));
            }

            Spacing = spacing;
            Texture = texture;
            LineSpacing = fontDesc.Common.LineHeight;
        }

        internal delegate void EachChar(char actual, Vector2 drawPosition, FontGlyph data, char? previous);
    }
}